2022-03-12  William A. Hudson

		Sine Wave DAC Program - dac_mcp4822
		-----------------------------------

Generate a sine wave with amplitude ramp control.
A program to operate an MCP4822 DAC on RPi rgUniSpi.

----------------------------------------------------------------------------
## Purpose
----------------------------------------------------------------------------

    Intended for exploring fiber scanner resonance frequency.

    Initial version with static frequency and amplitude.
    Then add amplitude ramp.
    Then add frequency sweep.

----------------------------------------------------------------------------
## Discussion
----------------------------------------------------------------------------

    Exciter will be driven by a current buffer.

Shared resources:

    The program cannot know what the actual external configuration is.
    Thus it should not reconfigure the Gpio pins, leave that to the user.

----------------------------------------------------------------------------
## Initial Thoughts
----------------------------------------------------------------------------

    Initial ideas of what needs to be controlled from the command line.

usage:  sine_mcp4822 [options]

  options:

    [-a|-b]         DAC channel (default is A)

    --freq=200.1    frequency in Hz
    --stride=20.3   stride thru wave table that makes frequency

    --amplitude=0.5 amplitude Vpp		--vpp=
    --gain=         gain multiplier for sine wave -1 to +1 Vpp

  ? --dacgain=      DAC gain setting, 1x or 2x (default 1x)

    --ramp=         ramp time in seconds
    --hold=         hold time in seconds


Behavior Requirements:

    Want command to ramp up amplitude from zero.  Make a smooth stimulus
    to exciter driving the fiber cantilever.

    When any program stops feeding new values to the SPI interface FIFO,
    the DAC will be left at the last voltage value.
    This may be an abrupt change, and may leave exciter driven.

    Want the output to smoothly ramp down to zero when program terminates.
    Of course this cannot happen if the program is killed.

    Thus the electronics must be arranged so no damage to exciter if it is
    left at a constant DC current.
    We can accept a rough transition as that should not damage anything.

    How does the program know to stop, i.e. ramp down?  Possibly:
    A)  Time delay option.  i.e. run for 5 seconds.
    B)  Send process a signal.
    C)  Gpio input pin could be a signal.
    D)  Check keyboard input.

    Want a status indicator to show ramping or stable state.

    Frequency could be hard to turn into internal parameters.  Maybe start
    with directly specifying internal parameters, and do a frequency
    measurement to make a calibration.

    Want Sync marks to gate LED to see stimulus phase in camera image of
    fiber scan pattern.

Frequency sweep:
    Used when looking for resonant frequency.

    Generally sweep frequency keeping amplitude constant.
    However we seem to see an hysteresis effect where the current response
    depends on the past stimulus.  To avoid this, we can ramp amplitude to
    zero between each frequency point, thus making each point independent of
    past stimulus.

    Possibly arrange an input signal to advance to the next frequency point.

    Experiment cycle could be:
    1) Ramp up to specified frequency and amplitude.
    2) Take picture of fiber response.
    3) Ramp down to zero amplitude.

    This could be done by a single-point program that ramps up, waits
    5 seconds for picture, then ramps down and exits.
    Or any of the ramp up/down signal methods.

    Possibly the program could trigger camera thru Gpio.
    This can work, but leads to program inversion.

    I favor having a separate high-level program doing the orchestrating
    of a camera program and the sine DAC program.

Frequency Parameters:
    Ideally frequency specified in Hz, and delays is seconds.

    Internal frequency is really the SPI Speed_12 parameter, and the numeric
    oscillator stride and wave table size.

    Internally delay by counting cycles.

Not Real-time OS:
    The RPi is running generic Linux, and is NOT real-time responsive.
    The main issue is any process can (and will) be put in a sleep state
    at any time.
    However it is easy to arrange for a single process to run with minimal
    disturbance.

    Summary:  We want the RPi running the DAC to pretty much be that one
    process running 100% CPU, with minimal other things.
    Thus put the camera on another RPi.

SPI Interface:  (rgUniSpi)

    SCLK frequency changes with ARM core frequency.
    Thus need a process "warmup" period to kick the OS to raise ARM frequency.
    Keeping high CPU usage will keep the frequency constant (i.e. not go into
    power saving), unless over temperature causes throttling.

    It may be tricky to keep a constant sample rate, but I think it is just
    possible.

----------------------------------------------------------------------------
## Frequency Calculation
----------------------------------------------------------------------------

    Nsize  = Number of entries used in table
    Stride = Stride stepping thru wave table

    Tsamp  = sample period, generally a given
    Tcyc   = oscillator cycle period (one output sine wave cycle)

    Fsamp  = 1 / Tsamp		= sample frequency
    Fcyc   = 1 / Tcyc		= oscillator frequency

    (1)  AnSamp  = Nsize / Stride	= average number of samples in a cycle


    (2)  Tcyc = AnSamp * Tsamp

    (3)      Tcyc = Tsamp * Nsize / Stride

    (4)      Fcyc = Stride / (Tsamp * Nsize)


    (5)  Stride = Fcyc * Tsamp * Nsize

    Want program to calculate frequency Fcyc, given a sample period Tsamp.
    Want program to compute Stride, given Fcyc.
    Possibly program could read Speed_12 to calculate Tsamp.

SPI Frequency:  (rgUniSpi)

    From:  dac_adc/code/doc/uspi_period.text
        --Speed_12           - Sets the SCLK clock frequency.
        Fsclk = Fsys / (2 * (Speed_12 + 1))		- SCLK frequency

	Tsclk = 1 / Fsclk		SLCK period

	Tsclk = 2 * (Speed_12 + 1) / Fsys

	On a RPi4:
        Fsys = 200 MHz  for  Farm =  600 MHz  idle
        Fsys = 500 MHz  for  Farm = 1500 MHz  full speed

    ShiftLength_6 = number of data bits shifted out in a SPI (CS) cycle.

    Nsclk = ShiftLength_6 + 2.5      = number of sclk periods in a SPI cycle

    Tsamp = Tsclk * Nsclk	= sample period (one SPI CS cycle).

Frequency Measurement:

    The program can count cycles, and measure the elapsed time with
    clock_gettime().  Thus can measure period and frequency.
    Use this as a measured result.


----------------------------------------------------------------------------
## Design
----------------------------------------------------------------------------


----------------------------------------------------------------------------
## sine_mcp4822 turn-on  2022-04-06
----------------------------------------------------------------------------

Configuration:
    RPi4:  rpiFour
    Circuit:  avolt_dac_v1/  v1.0
    Code:  sine_mcp4822.cpp  (commit 2a2d164ace)

Observations:

    Low pass filter working.  Produces a phase delay.

    Noise on output.
    Digital noise ~120 mVpp on Voa (final output).  This goes away
    when SPI stops clocking, i.e. CE2n goes high.

    % ../bin/sine_mcp4822 --gain=200 --stride=4.0 --nsamp=10000
	stride=4.0 --nsamp=10000
	Wtab.Nsize = 128
	Sox.Gain   = 200
	Sox.Offset = 2048
	Nox.Stride = 4.0000
	Nox.Phase  = 0.0000
	NperCycle  = 32.0000
	    loop_cnt=     5193819
	    fifo_cnt=     10000      55742 ns/fifo_write
	    overflow_cnt= 2
	    delta_ns=  557427296 ns,   107 ns/loop
	Fsamp =    17939.8 Hz
	Fcyc  =      560.6 Hz

    Vda (DAC) output:  200 mVpp sine wave.  Can see steps on each sample.

    Vfa filter output:  Looks clean, except for SCLK noise.
	The filter works!  But adds phase delay.

    Repeated runs can usually capture the ending cycle, with an even
    stride that ends on a zero crossing.  Can see the digital noise stop
    when oscillator stops.  Can see DAC steps on DAC output, gone on filter
    output.  Can see phase delay between DAC and Filter (in addition to the
    inverting filter output).  Very nice.

    Measured Fcyc ~625 Hz on oscilloscope, program measured Fcyc= 617 Hz.
    Amplitude is also close.

    % rgpio uspi -1
    Spi1:
       1.AuxEn    = 0x00000002
       1.Cntl0    = 0x2a300850
       1.Cntl1    = 0x00000000
       1.Stat     = 0x00400300
       1.Peek     = 0x00000000
       1.SpiEnable_1    = 1
       1.SpiIrq_1       = 0
     Cntl0
       1.Speed_12       = 675
       1.ChipSelects_3  = 0
       1.PostInMode_1   = 0
       1.VariableCs_1   = 0
       1.VariableWidth_1= 0
       1.DoutHoldTime_2 = 0
       1.EnableSerial_1 = 1
       1.InRising_1     = 0
       1.ClearFifos_1   = 0
       1.OutRising_1    = 0
       1.InvertClk_1    = 0
       1.OutMsbFirst_1  = 1
       1.ShiftLength_6  = 16
     Cntl1
       1.CsHighTime_3   = 0
       1.TxEmptyIrq_1   = 0
       1.DoneIrq_1      = 0
       1.InMsbFirst_1   = 0
       1.KeepInput_1    = 0
     Status
       1.TxLevel_3      = 0
       1.RxLevel_3      = 4
       1.TxFull_1       = 0
       1.TxEmpty_1      = 1
       1.RxFull_1       = 1
       1.RxEmpty_1      = 0
       1.Busy_1         = 0
       1.BitCount_6     = 0

Need:
 v  Measure Fsamp and Fcyc.

 v  Change sample_cnt to be the number of SPI cycles.

 v  Add a warmup period.
	This eliminated SCLK (Arm core) frequency change and made the frequency
	measurement more accurate.

 v  Add initial fill of Fifo.  Are getting overflow_cnt= 2.
	This eliminated the initial overflow counts.

    Add sync marks to program.

    Need trigger output for scope.  Perhaps near start or stop.

