2022-03-12  William A. Hudson

		Sine Wave DAC Program - dac_mcp4822
		-----------------------------------

Generate a sine wave with amplitude ramp control.
A program to operate an MCP4822 DAC on RPi rgUniSpi.

----------------------------------------------------------------------------
## Purpose
----------------------------------------------------------------------------

    Intended for exploring fiber scanner resonance frequency.

    Initial version with static frequency and amplitude.
    Then add amplitude ramp.
    Then add frequency sweep.

----------------------------------------------------------------------------
## Discussion
----------------------------------------------------------------------------

    Exciter will be driven by a current buffer.

Shared resources:

    The program cannot know what the actual external configuration is.
    Thus it should not reconfigure the Gpio pins, leave that to the user.

----------------------------------------------------------------------------
## Initial Thoughts
----------------------------------------------------------------------------

    Initial ideas of what needs to be controlled from the command line.

usage:  sine_mcp4822 [options]

  options:

    [-a|-b]         DAC channel (default is A)

    --freq=200.1    frequency in Hz
    --stride=20.3   stride thru wave table that makes frequency

    --amplitude=0.5 amplitude Vpp		--vpp=
    --gain=         gain multiplier for sine wave -1 to +1 Vpp

  ? --dacgain=      DAC gain setting, 1x or 2x (default 1x)

    --ramp=         ramp time in seconds
    --hold=         hold time in seconds


Behavior Requirements:

    Want command to ramp up amplitude from zero.  Make a smooth stimulus
    to exciter driving the fiber cantilever.

    When any program stops feeding new values to the SPI interface FIFO,
    the DAC will be left at the last voltage value.
    This may be an abrupt change, and may leave exciter driven.

    Want the output to smoothly ramp down to zero when program terminates.
    Of course this cannot happen if the program is killed.

    Thus the electronics must be arranged so no damage to exciter if it is
    left at a constant DC current.
    We can accept a rough transition as that should not damage anything.

    How does the program know to stop, i.e. ramp down?  Possibly:
    A)  Time delay option.  i.e. run for 5 seconds.
    B)  Send process a signal.
    C)  Gpio input pin could be a signal.
    D)  Check keyboard input.

    Want a status indicator to show ramping or stable state.

    Frequency could be hard to turn into internal parameters.  Maybe start
    with directly specifying internal parameters, and do a frequency
    measurement to make a calibration.

    Want Sync marks to gate LED to see stimulus phase in camera image of
    fiber scan pattern.

Frequency sweep:
    Used when looking for resonant frequency.

    Generally sweep frequency keeping amplitude constant.
    However we seem to see an hysteresis effect where the current response
    depends on the past stimulus.  To avoid this, we can ramp amplitude to
    zero between each frequency point, thus making each point independent of
    past stimulus.

    Possibly arrange an input signal to advance to the next frequency point.

    Experiment cycle could be:
    1) Ramp up to specified frequency and amplitude.
    2) Take picture of fiber response.
    3) Ramp down to zero amplitude.

    This could be done by a single-point program that ramps up, waits
    5 seconds for picture, then ramps down and exits.
    Or any of the ramp up/down signal methods.

    Possibly the program could trigger camera thru Gpio.
    This can work, but leads to program inversion.

    I favor having a separate high-level program doing the orchestrating
    of a camera program and the sine DAC program.

Frequency Parameters:
    Ideally frequency specified in Hz, and delays is seconds.

    Internal frequency is really the SPI Speed_12 parameter, and the numeric
    oscillator stride and wave table size.

    Internally delay by counting cycles.

Not Real-time OS:
    The RPi is running generic Linux, and is NOT real-time responsive.
    The main issue is any process can (and will) be put in a sleep state
    at any time.
    However it is easy to arrange for a single process to run with minimal
    disturbance.

    Summary:  We want the RPi running the DAC to pretty much be that one
    process running 100% CPU, with minimal other things.
    Thus put the camera on another RPi.

SPI Interface:  (rgUniSpi)

    SCLK frequency changes with ARM core frequency.
    Thus need a process "warmup" period to kick the OS to raise ARM frequency.
    Keeping high CPU usage will keep the frequency constant (i.e. not go into
    power saving), unless over temperature causes throttling.

    It may be tricky to keep a constant sample rate, but I think it is just
    possible.

Conversion Factors:  Gain, Stride
    Convert user units, mVpp and Hz, into internal factors of Gain and Stride.

    Conversion is based on a particular configuration of DAC, amplifiers,
    SPI sample rate, wave table size, etc.
    Ultimately the program could compute the conversion factors, but start
    with externally computed factors.

    Gain_mVpp  = Gain per mVpp
    Stride_Hz  = Stride per Hz

----------------------------------------------------------------------------
## Frequency Calculation
----------------------------------------------------------------------------

    Nsize  = Number of entries used in table
    Stride = Stride stepping thru wave table

    Tsamp  = sample period, generally a given
		Is the period from one CS to another.
    Tcyc   = oscillator cycle period (one output sine wave cycle)

    Fsamp  = 1 / Tsamp		= sample frequency
    Fcyc   = 1 / Tcyc		= oscillator frequency

    (1)  AnSamp  = Nsize / Stride	= average number of samples in a cycle


    (2)  Tcyc = AnSamp * Tsamp

    (3)      Tcyc = Tsamp * Nsize / Stride

    (4)      Fcyc = Stride / (Tsamp * Nsize)


    (5)  Stride = Fcyc * Tsamp * Nsize

    Want program to calculate frequency Fcyc, given a sample period Tsamp.
    Want program to compute Stride, given Fcyc.
    Possibly program could read Speed_12 to calculate Tsamp.

    Stride_Hz = Stride / Fcyc		Stride per Hz, Fcyc in Hz

    Stride_Hz = Tsamp * Nsize		Tsamp in seconds

SPI Frequency:  (rgUniSpi)

    From:  dac_adc/code/doc/uspi_period.text
	--Speed_12		- Sets the SCLK clock frequency.
	Fsclk = Fsys / (2 * (Speed_12 + 1))		- SCLK frequency

	Tsclk = 1 / Fsclk		SLCK period

	Tsclk = 2 * (Speed_12 + 1) / Fsys

	On a RPi4:
	Fsys = 200 MHz  for  Farm =  600 MHz  idle
	Fsys = 500 MHz  for  Farm = 1500 MHz  full speed

    ShiftLength_6 = number of data bits shifted out in a SPI (CS) cycle.

    Nsclk = ShiftLength_6 + 2.5      = number of sclk periods in a SPI cycle

    Tsamp = Tsclk * Nsclk	= sample period (one SPI CS cycle).

Frequency Measurement:

    The program can count cycles, and measure the elapsed time with
    clock_gettime().  Thus can measure period and frequency.
    Use this as a measured result.

----------------------------------------------------------------------------
## Amplitude (Gain) Calculation
----------------------------------------------------------------------------

Circuit:  avolt_dac_v1  v1.0

    Amplitude is mostly circuit dependent.
    DAC -> Amp Vo=(2*0.512V - Vi) -> Attenuator 4:1 -> Buffer

    Here we use the MCP4822 DAC in a +-1.0240 V Full Scale (FS) output mode
    provided by an inverting op-amp filter with offset (output Vfa).
    For a 12-bit DAC, LSB is 0.0005 V and the conversion equation is:

	Vfa = -0.0005 V * (Code - 2048)		offset output, filtered

	Code = (Vfa / 0.0005 V) + 2048		DAC digital code number

    The signal is then attenuated 4:1 and buffered:

	Voa = Vfa * 0.250			final output
	    = 0.125 mV * (Code - 2048)

	Code	Vfa		Voa (mV)
	----	----------	--------
	4095	-1.0235 V	-255.9
	4048	-1.0000 V	-250.0
	2048	 0.0000 V	   0.0
	  48	+1.0000 V	+250.0
	   0	+1.0240 V	+256.0

Conversion Factor:  Gain_mVpp

    We define Gain_mVpp such that:

	Gain = Gain_mVpp * User_mVpp	= Gain parameter

	User_mVpp       = user input, in mVpp, range -256 to +255

	Gain is the scale factor used in dNcScaler::set_Gain(), and is
	a Q14.0 value with range [-MaskFS to MaskFS].
	In this particular case (MCP4822 DAC in program sine_mcp4822.cpp)
	Gain is in the range [-2047 .. +2047].
	#!! should it be [-2048 .. +2048]?

	Essentially the wave table entry Q2.30 value in range [-1.0 to +1.0]
	is multiplied by (Gain / 2048).

    Thus

	Gain_mVpp = Gain / User_mVpp

	So for overall conversion we want  User_mVpp= 250.0  to produce
	Gain= 2000, and thus  Gain_mVpp= 8.000 .
	Just applying nominal range from the table, not the absolute max
	range, to keep numbers simple.  i.e. Use full scale code +-2000
	instead of the binary +-2048, leaving a little bit of headroom.

----------------------------------------------------------------------------
## Sync Marks
----------------------------------------------------------------------------

    Sync Marks are digital output signals aligned with interesting points
    of the output waveform.

    For the Fiber Scanner we want to see the phase of the drive signal and
    the direction the ellipse is traced in the camera image.

Jitter in the Sync Mark:
    Jitter is intrinsic, with magnitude equal to the sample period Tsamp.
    It can be reduced by increasing the number of samples per cycle.

	Tsamp = Tcyc * Stride / Nsize		Jitter in seconds, is the
						    sample period

	(Tsamp / Tcyc) = Stride / Nsize		Jitter as fraction of a cycle
		       = 1 / AnSamp

    Jitter is zero when Stride is an integer factor of the table size Nsize.
    In that case the same set of table indices are selected each cycle.
    Stride itself need not be an integer.  (e.g. 2.5 * 100 = 250)
    i.e.

	Stride * M = Nsize		Zero jitter, where M= integer

	Stride / Nsize = M

Stored Sync Marks:
    The sync mark bits can be stored in the low order bits of the wave table
    entries, which are discarded in the actual waveform.  Essentially it
    is a binary waveform issued along with the analog sine wave.  This was
    the original idea.

    An arbitrary binary wave form can be stored, and is fairly easy to issue.
    However the position of the edges is not easily changed on the fly, i.e.
    must re-write the table.

    A stored sync mark must be at least as wide (the number of entries) as
    Stride to ensure that it is hit at least once per cycle.  Generally
    round Stride up to the next integer.  Note that in some cases a minimal
    width mark may result in one or two samples, resulting in width jitter
    in addition to position jitter.

Computed Sync Marks:
    The sync mark edges could be computed based on the wave table index
    currently being issued, essentially the accumulated Stride.
    e.g.

	if ( (Index > EdgePose) && (Index < (EdgePose + Stride)) ) {
	    Output sync mark pulse (one sample).
	}

    This is easy to dynamically change, but mostly appropriate for just a
    few edges.  The same width and jitter issues occur.

LED Gate:
    Can have multiple sync marks.  Possibly externally choose which one to
    apply to the LED gate.

    A sync mark that is half the sine wave works well to mark the zero
    crossings of the sine wave.  Half the ellipse is in darkness, making
    it a bit harder to see the full extent.

    Sync marks that disable the LED for only one sample at each zero crossing
    would allow the full ellipse to be seen.

    The direction of the ellipse tracing cannot be determined if the sync
    marks have symmetry on the sine wave cycle, the pattern is the same
    whether time progresses forward or backward.  e.g. Equal width pulses
    at the drive zero crossings.

    Introduce asymmetry by making one pulse wider, or by adding a third pulse
    unequally spaced between the first two.

    The best time resolution is near the center of the ellipse pattern, where
    the trace is moving fastest.  The trace is moving slower at the tips of
    the ellipse.
    Thus is may be desirable to position the sync marks at the center of
    the ellipse, or at the axis crossings, and read out the resulting
    phase delay.

    The axis crossings of the ellipse pattern are the X and Y sinusoid
    zero-crossings of the response waveform.
    This is the phase delay of the response from the drive.

    The maximum X and Y displacements are the response amplitudes.
    This is essentially the bounding box of the ellipse (for which we already
    have program pgm_box).

----------------------------------------------------------------------------
## Current Implementation
----------------------------------------------------------------------------

Describe what and how the current program works.


----------------------------------------------------------------------------
## sine_mcp4822 turn-on  2022-04-06
----------------------------------------------------------------------------

Configuration:
    RPi4:  rpiFour
    Circuit:  avolt_dac_v1/  v1.0
    Code:  sine_mcp4822.cpp  (commit 2a2d164ace)

Observations:

    Low pass filter working.  Produces a phase delay.

    Noise on output.
    Digital noise ~120 mVpp on Voa (final output).  This goes away
    when SPI stops clocking, i.e. CE2n goes high.

    % ../bin/sine_mcp4822 --gain=200 --stride=4.0 --nsamp=10000
	stride=4.0 --nsamp=10000
	Wtab.Nsize = 128
	Sox.Gain   = 200
	Sox.Offset = 2048
	Nox.Stride = 4.0000
	Nox.Phase  = 0.0000
	NperCycle  = 32.0000
	    loop_cnt=     5193819
	    fifo_cnt=     10000      55742 ns/fifo_write
	    overflow_cnt= 2
	    delta_ns=  557427296 ns,   107 ns/loop
	Fsamp =    17939.8 Hz
	Fcyc  =      560.6 Hz

    Vda (DAC) output:  200 mVpp sine wave.  Can see steps on each sample.

    Vfa filter output:  Looks clean, except for SCLK noise.
	The filter works!  But adds phase delay.

    Repeated runs can usually capture the ending cycle, with an even
    stride that ends on a zero crossing.  Can see the digital noise stop
    when oscillator stops.  Can see DAC steps on DAC output, gone on filter
    output.  Can see phase delay between DAC and Filter (in addition to the
    inverting filter output).  Very nice.

    Measured Fcyc ~625 Hz on oscilloscope, program measured Fcyc= 617 Hz.
    Amplitude is also close.

    % rgpio uspi -1
    Spi1:
       1.AuxEn    = 0x00000002
       1.Cntl0    = 0x2a300850
       1.Cntl1    = 0x00000000
       1.Stat     = 0x00400300
       1.Peek     = 0x00000000
       1.SpiEnable_1    = 1
       1.SpiIrq_1       = 0
     Cntl0
       1.Speed_12       = 675
       1.ChipSelects_3  = 0
       1.PostInMode_1   = 0
       1.VariableCs_1   = 0
       1.VariableWidth_1= 0
       1.DoutHoldTime_2 = 0
       1.EnableSerial_1 = 1
       1.InRising_1     = 0
       1.ClearFifos_1   = 0
       1.OutRising_1    = 0
       1.InvertClk_1    = 0
       1.OutMsbFirst_1  = 1
       1.ShiftLength_6  = 16
     Cntl1
       1.CsHighTime_3   = 0
       1.TxEmptyIrq_1   = 0
       1.DoneIrq_1      = 0
       1.InMsbFirst_1   = 0
       1.KeepInput_1    = 0
     Status
       1.TxLevel_3      = 0
       1.RxLevel_3      = 4
       1.TxFull_1       = 0
       1.TxEmpty_1      = 1
       1.RxFull_1       = 1
       1.RxEmpty_1      = 0
       1.Busy_1         = 0
       1.BitCount_6     = 0

Need:
 v  Measure Fsamp and Fcyc.

 v  Change sample_cnt to be the number of SPI cycles.

 v  Add a warmup period.
	This eliminated SCLK (Arm core) frequency change and made the frequency
	measurement more accurate.

 v  Add initial fill of Fifo.  Are getting overflow_cnt= 2.
	This eliminated the initial overflow counts.

    Add sync marks to program.

    Need trigger output for scope.  Perhaps near start or stop.

