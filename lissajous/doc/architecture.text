2020-09-25  William A. Hudson

		Lissajous Image Rendering
		-------------------------

The Fiber Scanner scans the object plane in a Lissajous Figure pattern.
Pixel intensity is sampled at a regular interval.
Want to render the image stream into an rectangular X-Y pixel image.

Can sample an existing rectilinear image to generate a Lissajous image
stream for exploration/testing.

References:

[1] High-speed Lissajous-scan atomic force microscopy:  Scan pattern planning
    and control design issues
    Rev. Sci. Instrum. 83, 063701 (2012); https://doi.org/10.1063/1.4725525
    Published Online: 04 June 2012
    https://aip.scitation.org/doi/pdf/10.1063/1.4725525
    Good explanation of dense Lissajous figure ellipses and repeat time.

----------------------------------------------------------------------------
## Lissajous Pattern
----------------------------------------------------------------------------

    Here I try to find a way of expressing a Lissajous pattern of the
    type that interests us for image scanning.  These statements try to
    convey my thoughts, but may not be exactly correct.
    My derivation from first principles.

Generation:
    Generated by X and Y axis displacement of a sampling point.
    Both X and Y displacements are a sine wave as a function of time.

    Displacement as a function of time t:
	X = Ax * sin( Wx * t )	# X displacement
	Y = Ay * sin( Wy * t )	# Y displacement

	Ax, Ay  are amplitude scale factor (um)
	Wx, Wy  are frequency of oscillation (radians/s) - small omega

    If X and Y were exactly the same frequency, but differ only in phase,
    the trace will look like an ellipse:
    A 45 degree positive slope line when Ph= 0
    A circle when Ph = Pi/2, (90 degrees)
    A 45 degree negative slope line when Ph= Pi, (180 degrees)
    An ellipse of various width in-between.
    Each cycle exactly closes on itself, pattern appears stationary.

    When the frequencies differ by a tiny amount, the trace will look like
    an ellipse that changes shape (width) as the phase between X and Y
    continuously changes.

    Think of frequency Wy as being constant with an added monotonically
    increasing phase shift:

	Wx = W			= constant
	Wy = W + Ph( t ),
	    Ph(t) = A * t,	phase (radians) change as a function of time t
		A = constant
		t = time

    A Lissajous pattern have X and Y at slightly different frequencies.
    Define the sine wave frequencies as number of cycles in period Tr:
	X:  N      cycles in time Tr
	Y:  N + 1  cycles in time Tr

	N is large (e.g. 100)

    The pattern will repeat in time Tr.
    In the time Tr it takes X to make N cycles, Y will make (N+1) cycles.

    Now each cycle will look like an ellipse that does not quite close on
    itself.

    Generalize the pattern:
	X:  N      cycles in time Tr
	Y:  N + K  cycles in time Tr

	where N >> K
	K = prime integer (e.g. 11)
	N = integer, prime w.r.t. K, and large  (e.g. 100)

	Now divide both X and Y by K to see pattern:
	X:  (N / K)      cycles in time  (Tr / K)
	Y:  (N / K) + 1  cycles in time  (Tr / K)

	This is the N+1 Lissajous pattern, but (N/K) is not an integer, so
	the pattern does not close.

	Now the ratio N/K is not an integer, but can be written as
        (N / K) = M + (J / K)
	    where
	    M = integer, the integer part of N/K
	    J = integer {1 .. K-1}, the remainder
	and
	X:  M + (J / K)      cycles in time  (Tr / K)
	Y:  M + (J / K) + 1  cycles in time  (Tr / K)

	This can be interpreted as one Lissajous pattern that does not
	close by (J / K) fraction of a cycle in time (Tr / K).
	After K such patterns, it closes (the trace repeats on itself).

	Now M is the number of cycles (of the sine wave) needed to fill one
	pattern that does not quite close on itself.
	The integer K is the number of patterns needed to close exactly, and
	J is the stride through those patterns.

	Multiply thru by K and we have:
	X:  (K *  M) + J       cycles in time  Tr
	Y:  (K * (M + 1)) + J  cycles in time  Tr

	Define:
	    Nx = (K *  M) + J
	    Ny = (K * (M + 1)) + J

	    Ny = Nx + K,    but Nx is constrained as above
				   i.e. Nx is not divisible by K 

	    M = large integer, want M >> K, e.g. 100
	    K = prime integer is number of passes over the field, (e.g. 11)
	    J = integer {1 .. K-1}  is the stride thru the patterns

        K is important for scanning a sample.  When K=1, the scan is
	essentially a single pass of a morphing ellipse.  If the time Tr is
	long, e.g. 10 seconds, then it takes that long to cover the full frame,
	much like a slow rectilinear line scan.  When K is larger, e.g. K=11,
	then the frame is covered 11 times, slightly offset each time, in
	the time Tr, essentially coarsely sampling the whole frame in time
	(Tr / K) and filling in more samples in each of K passes.
	This is important if the object being scanned changes during the
	scan (maybe how?).

	This seems pretty good :-)

2021-06-27
    Require Nx and Ny to not have a common factor.
    M can be any integer.
    K can be any integer, not required to be prime.
    J=0 when K=1.

----------------------------------------
2021-06-27  Stride J = integer {1 .. K-1}  and J=0 when K=1.

    When K=1, J can be either 0 or 1.

	Nx = (K *  M) + J
	Ny = (K * (M + 1)) + J

    K=1, J=0
	Nx = M
	Ny = M + 1

    K=1, J=1
	Nx = M + 1
	Ny = M + 2

	But replace integer (M + 1) with N, and it is the same relation.
	Thus better to choose J=0 when K=1.

	Can not allow J=0 in general because J is the stride, and J/K is the
	fraction remaining in each pass.  If J=0, then there is no stride, and
	the pattern collapses to
	    Nx = K * M
	    Ny = K * (M + 1)

	    Now Nx and Ny have a common factor K, which is the mode collapse.

----------------------------------------
2021-06-27  Try Interpreting the K,M,J relations.

    Define number of cycles in time Tr where pattern repeats exactly:
	Nx = (K *  M) + J
	Ny = (K * (M + 1)) + J

	Ny = Nx + K,    but Nx is constrained as above
			       i.e. Nx is not divisible by K 

	M = large integer, want M >> K, e.g. 100
	K = integer is number of passes over the field, (e.g. 11)
	J = integer {1 .. K-1}  is the stride thru the patterns, J=0 when K=1

	Require Nx and Ny to not have any common factor, to avoid mode collapse.
	Not sure making K prime helps.

	Generally we want K=1 to repeat in a single pass.  J=0
	    Nx = M
	    Ny = M + 1

    Frequency
	Fx = Nx / Tr
	Fy = Ny / Tr

	Wx = 2*Pi * Fx
	Wy = 2*Pi * Fy

    Displacement as a function of time t:
	X = Ax * sin( Wx * t )	# X displacement
	Y = Ay * sin( Wy * t )	# Y displacement

	Wx = (2*Pi / Tr) * ((K *  M) + J)
	Wy = (2*Pi / Tr) * ((K * (M + 1)) + J)

	Essentially Tr and the integer part defines the frequency.

    We want the equations to represent the full pattern without any
    mode collapse, no common divisors.
    When K=1, Tr is the time for full pattern.

    Solve for Tr
	Fx = ((K *  M) + J) / Tr
	Fy = ((K * (M + 1)) + J) / Tr

	Nx = Fx * Tr  = (K *  M) + J
	Ny = Fy * Tr  = (K * (M + 1)) + J

	Subtract:
	Ny - Nx = (Fy - Fx) * Tr  = K

 >>	Tr = K / (Fy - Fx)
	    Time to pattern repeats exactly, making K passes over field.
	    Is a more general form.
	    This relates well to the Tc making one pass over field below.
	    Require Fx, Fy related as above, they are NOT arbitrary.

Choosing parameters:
    Generally, Fx is pre-determined by the resonant frequency.

    M, K, J are completely free to choose.  These define the pattern.

    K is the number of passes (field patterns) to repeat exactly.
    Generally we want a single pass pattern, so K=1.

    M is the number of cycles in the first field pattern (i.e. one pass),
    which is M/2 cycles of 45 degree ellipse plus M/2 cycles of 135 degree
    ellipse.  Thus M/2 is number of ellipses across one field, and
    (M/2)*2 the number of lines.

    Li = K * M		number of diagonal lines across field in full pattern

    J is the stride thru the field patterns,
    J = {1 .. K-1}, J=0 when K=1
    Beware of mode collapse, e.g. K=8, J=4 ?

    Nx = (K *  M) + J
    Ny = (K * (M + 1)) + J

    Tr is the time for pattern to repeat exactly, derives from Fx.

    Tr = ((K * M) + J) / Fx

    Then
    Fy = Fx + (K / Tr)

    Fy = Fx + ( (K * Fx) / ((K * M) + J) )

    Fy = Fx * (1 + K / ((K * M) + J) )

    Fy = Fx * (1 + 1 / (M + J/K) )

    This looks very good.  :-)
    Adjust pattern integers to get reasonable Tr and Fy.

    Cross-check
	Tr = K / (Fy - Fx)
	Tr = K / (Fx + (K / Tr) - Fx)
	Tr = K / (K / Tr)
	Tr = Tr

    When K=1 and J=0:  (Y makes one more cycle than X in time Tr)
	Nx = M
	Ny = M + 1
	Tr = M / Fx

	Fx = M / Tr		definition of Tr
	Fy = (M + 1) / Tr

	Fy = Fx + (1 / Tr)
	Fy = Fx * (1 + (1 / M))

	Tr = 1 / (Fy - Fx)	derived earlier
	    Check:
	    Tr = 1 / ((M + 1) / Tr - M / Tr)
	    Tr = Tr

----------------------------------------
2021-07-13  Frequency Ratio

    Frequency
	Fx = Nx / Tr
	Fy = Ny / Tr

	Fx / Fy = Nx / Ny

	Nx = Fx * Tr  = (K *  M) + J
	Ny = Fy * Tr  = (K * (M + 1)) + J

	Nx / Ny = ( (K * M) + J ) / ( (K * M) + K + J )
	        = ( M + J/K ) / ( M + 1 + J/K )

	At K=1, J=0:
	    Nx / Ny = M / (M + 1)

    Not very revealing.

Example:  Require (Fy > Fx) so that (Ny > Nx)
    Fx = 363 Hz
    Fy = 369 Hz

    Remove least common factor, must be coprime.
    Nx / Ny = Fx / Fy  = 363 Hz / 369 Hz  = 121 / 123

    Nx = 121   = (K *  M) + J
    Ny = 123   = (K * (M + 1)) + J

    K = Ny - Nx

	K = 123 - 121 = 2

    Nx - J = K *  M
    Ny - J = K * (M + 1)

    Require  J=1  when K=2
	Nx = 121   = (2 *  M) + 1		M = 60
	Ny = 123   = (2 * (M + 1)) + 1		M = 60

    Thus:  K=2, M=60, J=1

    Tr = K / (Fy - Fx)  = 2 / (369 Hz - 363 Hz)  = 1 / 3  = 0.333 s

Example:
    Fx = 364 Hz
    Fy = 369 Hz

    Nx = 364	Are coprime
    Ny = 369

    K = 5
    J = 4 
    M = 72

    Nx = (K *  M) + J       = (5 *  72) + 4      = 364
    Ny = (K * (M + 1)) + J  = (5 * (72 + 1)) + 4 = 369

    Tr = K / (Fy - Fx)  = 5 / (369 Hz - 364 Hz)  = 1.000 s

Example:
    Fx = 365 Hz
    Fy = 369 Hz

    Nx = 365	Are coprime
    Ny = 369

    K = 4
    J = 1 
    M = 91

    Nx = (K *  M) + J       = (4 *  91) + 1      = 365
    Ny = (K * (M + 1)) + J  = (4 * (91 + 1)) + 1 = 369

    Tr = K / (Fy - Fx)  = 4 / (369 Hz - 365 Hz)  = 1.000 s

Example:
    K = 3
    J = 1 
    M = 121

    Nx = (K *  M) + J       = (3 *  121) + 1      = 364
    Ny = (K * (M + 1)) + J  = (3 * (121 + 1)) + 1 = 367

    Tr = K / (Fy - Fx)  = 3 / (367 Hz - 364 Hz)  = 1.000 s

----------------------------------------
2021-06-27  Time to advance one cycle.

    Time Tc for Y to advance at least one cycle:
 (1)	Nx 			integer number of cycles in X
	Nfy = Nx + 1 + R	integer plus a fractional cycle

	    R == remainder fraction cycle, 0 <= R < 1, definition

 (2)	Fx = Nx  / Tc
	Fy = Nfy / Tc

	Fy = (Nx + 1 + R) / Tc
	Fy = Fx + (1 + R) / Tc

 (3)	(R + 1) = (Fy - Fx) * Tc

	In a way, R represents the error in closure for an N+1 pattern.

	Tc represents the minimum time for Y to first advance by one cycle,
	where X must be an integer number of cycles.  Is very quantized by X
	complete cycles.

	(R + 1) = Nfy - Nx	(3, 2)

    How to find Tc given Fx, Fy?
	By the original definition of Tc, keep incrementing Nx until
 (4)	    Nfy >= Nx + 1
	    Tc = Nx / Fx	(2)

	Nx  = Fx * Tc		(2)
	Nfy = Fy * Tc		(2)

	(Fy * Tc) >= (Fx * Tc) + 1	(4)

	(Fy - Fx) * Tc >= 1

 >>(5)	Tc >= 1 / (Fy - Fx)	Time for one pass over field

 >>(6) 	Nx = Fx / (Fy - Fx)	Number of X cycles in Tc	(5, 2)

	    Nx = 1 / ((Fy / Fx) - 1)

	Nfy = Fy * Tc
	Nfy = Fy / (Fy - Fx)

	Is Nx really integer?  What am I missing?
	    Fx = 307.01,  Fy = 308.01,  Tc = 1.000,  Nx = 307.01

	Walk Nx:  Tc = Nx / Fx,  Nfy = Fy * Tc
	    Nx = 306, Tc = 0.9967,    Nfy = 306.9967
	    Nx = 307, Tc = 0.999967,  Nfy = 307.999967
	    Nx = 308, Tc = 1.003224,  Nfy = 309.003224,  R = 0.003224

	Walk Nx:  Fx = 300.5, Fy = 301.5,  Tc = Nx / Fx,  Nfy = Fy * Tc
	    Nx = 299, Tc = 0.995008,  Nfy = 299.995008
	    Nx = 300, Tc = 0.998336,  Nfy = 300.998336
	    Nx = 301, Tc = 1.001663,  Nfy = 302.001664,  R = 0.001664

	Walk Nx:  Fx = 300.5, Fy = 302.5,  Tc = Nx / Fx,  Nfy = Fy * Tc
	    Nx = 150, Tc = 0.499168,  Nfy = 150.998336
	    Nx = 151, Tc = 0.502495,  Nfy = 152.004991,  R = 0.004991

	Seems like equations (5, 6) are an estimate of Tc and Nx.  Compute
	Nx and round up to get the cycle accurate definition values.

	Thus Nx above is NOT an integer in general.

    Now eq (3) does not make sense
	(R + 1) = (Fy - Fx) * Tc
	(R + 1) = (Fy - Fx) / (Fy - Fx)
	(R + 1) = 1

	Somehow the requirement that Nx be integer got lost.

----------------------------------------
2021-06-27  Time to advance by 2*Pi.

    Find the time for Ph(t) to advance by 2*Pi.
    Then X is not an integer number of cycles.
    This might be more concise and less quantized.

    Displacement as a function of time t:
 (1)	X = Ax * sin( Wx * t )	# X displacement
	Y = Ay * sin( Wy * t )	# Y displacement

	    Ax, Ay  are amplitude scale factor (um)
	    Wx, Wy  are frequency of oscillation (radians/s) - small omega

    Think of frequency Wy as being constant with an added monotonically
    increasing phase shift:

 (2)	X = Ax * sin( Wx * t )		# X displacement
	Y = Ay * sin( Wx * t + Ph(t) )	# Y displacement

	    Wx = constant, use as the reference frequency

 (3)	Ph(t) = B * t,	phase (radians) change as a function of time t
	    B = constant
	    t = time

	Y = Ay * sin( (Wx * t) + (B * t) )	# Y displacement
	  = Ay * sin( (Wx + B) * t )

 (4)	Wy = Wx + B		gives B

    Time Tc for Y to advance by 2*Pi (one cycle):
 (5)	2*Pi = Ph( Tc )  = B * Tc

 	2*Pi = (Wy - Wx) * Tc		(5, 4)

	Tc = 2*Pi / (Wy - Wx)

	Wx = 2*Pi * Fx
	Wy = 2*Pi * Fy

 >>(6)	Tc = 1 / (Fy - Fx)	Time for Y to advance by 2*Pi w.r.t. X.
				    Is time for one pass over the field.

	This is the same as the one cycle advance above.

    This result for Tc seems solid, and does not imply nor require any
    integer relationships.

    Visualization:  When Nx is large.  Starting at t=0, the ellipse looks
    like a 45 degree line, that opens to circle, collapses to 135 degree
    line, opens to circle and finally collapses to 45 degree line.  There
    are Nx ellipses.  When Nx is large, it does not matter much if that
    final ellipse is complete or fractional.

    I wonder if the Tc value is essentially the average frequency completing
    an integral number of cycles?

    Fractional cycles in time Tc
	Nfx = Fx * Tc
	Nfy = Fy * Tc

	Nf = (Nfx + Nfy) / 2		average number of cycles

	   = (Fx + Fy) * Tc / 2

	   = (Fx + Fy) / (Fy - Fx) / 2

       Does not seem any more integral than Nfx or Nfy.


    Examples
	Fx = 300.5, Fy = 301.5 Hz,  Tc = 1.000000 s


    Perhaps a better insight:  For any two frequencies the ellipse
    continuously evolves, and there is no true "straight 45 degree line".
    Thus it makes sense that Nfx is not generally integral.

    When Fx and Fy have an integral relationship, then Tc will be an
    integral number of cycles.  (Conjecture)

----------------------------------------
2021-06-30  Scan time to cover field

See reference [1].

The Time to advance by 2*Pi (2021-06-27 above) is true in general for any
two frequencies Fx, Fy.
Think about number of passes over the field.

Four Pass, 2*Pi:  (two Lissajous knots)

    Tc = 1 / (Fy - Fx)	Time for Y to advance by 2*Pi w.r.t. X (one cycle),
			    two Lissajous knots which may not close, or
			    may exactly overlap.

    Observation shows that this Tc is actually two passes over the field,
    where the second pass is in the opposite direction of the first pass.
    This is seen looking at the sinusoids for X and Y.

    The  first pass is Ph(t) in [0 .. Pi].
    The second pass is Ph(t) in [Pi .. 2*Pi].

    For image scanning purposes it is not important that a Lissajous pattern
    exactly closes.  A single pass with incrementally displaced scan lines
    is sufficient.

Two Pass, Pi:  (one Lissajous knot)

    Tch := Tc / 2	Time for Y to advance by Pi w.r.t. X (half cycle),
			    a single pass Lissajous pattern which may not close.
    Tch = 1 / (2 * (Fy - Fx))

    This pattern has ellipses with long axis at 45 degrees followed by
    ellipses at 135 degrees.  Essentially two roughly orthogonal passes over
    the field.

One Pass, Pi/2:  (one elliptical scan)

    Tcq := Tch / 2	Time for Y to advance by Pi/2 w.r.t. X (quarter cycle).
			    a half pass Lissajous pattern.
    
    Tcq = 1 / (4 * (Fy - Fx))

Position of time segment:

    Note that the Tc interval can be at any arbitrary time position.  It is
    always two Lissajous knots that may not close, i.e. may have a small
    delta distance between start and end, or may exactly retrace.  The
    start (and end) point can be anywhere in the pattern with minimal effect.

    However, Tcq will not cover the field, i.e. an ellipse evolving between a
    line and a circle, unless it begins at a particular phase.

    Tcq:  Ph(t) = N * Pi/2,  where N = integer.  i.e. {0, Pi/2, Pi, 3*Pi/2}

    Similarly, Tch must start at phase

    Tch:  Ph(t) = N * Pi,  where N = integer.  i.e. {0, Pi}

Field coverage:

    The core field is bounded by the circle.  The corners are filled in as
    part of the evolving ellipse, and are covered twice, even with the one-pass
    elliptical scan.  It takes two orthogonal elliptical scans to cover all
    four corners.

    I would suggest either leave the corners out of the image, or use only
    the long axis of the ellipse to be coherent with the center circle area.

Image Scanning:

    For image scanning, a single pass with scan lines all the same direction
    will yield a more coherent image in the face of errors and perturbations
    during the time of acquisition.

    A multi-pass scan is essentially an overlay of multiple lower resolution
    images.  This may be helpful to get coarse resolution image quickly with
    more points filled in as time goes on.

    When the object is moving (changing) during the time of scan, the
    single-pass scan will look more coherent, but distorted.  The multi-pass
    scan would probably look more blurry.

----------------------------------------
2021-06-24  More thoughts - Trying to improve derivation - NOT that helpful

    Any two frequencies will make a Lissajous pattern.  What is the nature
    of that pattern?

[Trying to improve on the derivation above, but not working out.]

Generation:
    Generated by X and Y axis displacement of a sampling point.
    Both X and Y displacements are a sine wave as a function of time.

    Displacement as a function of time t:
	X = Ax * sin( Wx * t )	# X displacement
	Y = Ay * sin( Wy * t )	# Y displacement

	Ax, Ay  are amplitude scale factor (um)
	Wx, Wy  are frequency of oscillation (radians/s) - small omega

    Think of frequency Wy as being constant with an added monotonically
    increasing phase shift:

	Wx = constant, use as the reference frequency
	Wy = Wx + Ph( t ),
	    Ph(t) = B * t,	phase (radians) change as a function of time t
		B = constant
		t = time

	X = Ax * sin(  Wx          * t )	# X displacement
	Y = Ay * sin( (Wx + Ph(t)) * t )	# Y displacement

    Thus
	Wy = (Wx + (B * t))

	X = Ax * sin( Wx * t )	# X displacement
	Y = Ay * sin( (Wx + (B * t)) * t )	# Y displacement
	  = Ay * sin( (Wx * t) + (B * t * t) )	# Y displacement
	[Does not seem to be a useful insight.]

    Let
	Wy = (Wx + B)
	B  = constant

	B = Wy - Wx

	X = Ax * sin(    Wx    * t )	# X displacement
	Y = Ay * sin( (Wx + B) * t )	# Y displacement

	Y = Ay * sin( (Wx * t) + (B * t) )	# Y displacement

    Think of frequency Wy as being constant with an added monotonically
    increasing phase shift:

	Wx = W			= constant
	Wy = W + Ph( t ),
	    Ph(t) = B * t,	phase (radians) change as a function of time t
		B = constant
		t = time

    Let Wx be constant, and Wy to be close in frequency.  i.e.
	B << Wx

	Wy - Wx << Wx

	(Wy / Wx) - 1 << 1	i.e.  Wy/Wx near 0


Time to Repeat pattern - derivation

	Tr = Time for one pass, i.e. 2*Pi phase change.
	Pi = constant pi, 2*Pi is one full circle in radians (360 degrees)

    Interested in time for only one pass over pattern, without exactly
    repeating the trace.

	X = Ax * sin(  Wx          * t )	# X displacement
	Y = Ay * sin( (Wx + Ph(t)) * t )	# Y displacement

    The time to repeat is when phase shift between X and Y is one cycle
	Ph( Tr ) = 2*Pi

	B * Tr = 2*Pi

	(Wy - Wx) * Tr = 2*Pi

 >>	Tr = 2*Pi / (Wy - Wx)

 >>	Tr =    1 / (Fy - Fx)

	Note that Y has made one more complete cycle in time Tr, but both X
	and Y may have completed an integer plus fraction number of cycles.



---------
    Let Wx be constant, and Wy to be close in frequency.

	Wx = constant
	Wy = Wx + Ph(t)

	Wx = W			= constant
	Wy = W + Ph( t ),
	    Ph(t) = A * t,	phase (radians) change as a function of time t
		A = constant
		t = time

	Wy = Wx + (A * t),

	A = Wy - Wx


    The time to repeat is when phase shift between X and Y is one cycle
	Ph( Tr ) = 2*Pi

    Stated in terms of frequency, this is:
	Fx = constant
	Fy = Fx + (1 cycle)/(2*Pi)

    Number of cycles in Tr, fractional values
	Nfx = Fx * Tr
	Nfy = Fy * Tr

	Nfy = Nfx + 1		constrain lissajous pattern to close

	Nfx + 1 = Fy * Tr

	(Fx * Tr) + 1 = Fy * Tr

	Solve for Tr

	1 = (Fy * Tr) - (Fx * Tr)

	Tr = 1 / (Fy - Fx)

 >>	Tr = 1 / |Fy - Fx|

	Note that Y has made one more complete cycle in time Tr, but both X
	and Y may have completed an integer plus fraction number of cycles.


    Number of cycles in Tr
	Nx = Fx * Tr
	Ny = Fy * Tr

	Fx, Fy  = frequency in Hz
	    Wx = 2*Pi * Fx
	    Wy = 2*Pi * Fy
	       = (2*Pi radians/cycle) * (cycle/s)  = (radians/s)

	Nx = Tr * Wx / (2*Pi)
	Ny = Tr * Wy / (2*Pi)

	Substituting Wy above

	Nx = Tr * Wx / (2*Pi)
	Ny = Tr * (Wx + 2*Pi) / (2*Pi)

	Solve for Tr


    Displacement as a function of time t:
	X = Ax * sin( Wx * t )	# X displacement
	Y = Ay * sin( Wy * t )	# Y displacement


----------------------------------------
2021-06-28  Ideas from reference

[1] High-speed Lissajous-scan atomic force microscopy:  Scan pattern planning
    and control design issues
    Rev. Sci. Instrum. 83, 063701 (2012); https://doi.org/10.1063/1.4725525

Dense Lissajous pattern observations:
    Confirm the 4 quarter patterns that I found.
    Confirm my Tr = 1 / |Fy - Fx|  equation.
    Confirm single pass, or half pass, is better for scanning.
    Confirm quarter pattern ellipse has least redundancy, but miss two
	corners.  I think even use only the center circle.

    New insights for me:

    The progression around the ellipse reverses direction on opposite sides
    of the diagonal line.

    The second half pattern re-traces the first half pattern in reverse.

    Uses the Fx/Fy frequency ratio integer relationship.  I should explore
    this.

    Computes crossing points and line spacing.

    Uses time to track position in the trace.  I prefer using phase.

Many papers seem to have a poor treatment of the actual scan pattern.
Google search has lots of the typical introductory Lissajous patterns.
This one seemed to get it right.


----------------------------------------------------------------------------
## Rise Time and Bandwidth  (2021-06-24)
----------------------------------------------------------------------------

See:  ~/misc/oscilloscope.text

Relationship Between Rise Time and Bandwidth for a Low-Pass System
    https://www.thorlabs.com/newgrouppage9.cfm?objectgroup_id=9817
    A good series of related notes.
    Tr = 0.35 / F3db	approximate rise time
    F3db = 3 db bandwidth of first order low-pass system

How is bandwidth related to rise time for oscilloscopes?
    https://www.tek.com/support/faqs/how-bandwidth-related-rise-time-oscilloscopes
    High end real-time digital oscilloscopes have a steeper roll-off, thus
    Tr = 0.45 / F3db	approximate rise time

Oscilloscope sample rate should be 5 times bandwidth for reasonable fidelity.

Our scanner needs a much higher bandwidth, or much slower scanning speed.

For our NiDaq:
    Sample rate:  Sr = 100 kHz  
    Bandwidth:    Bw = Sr / 5 = 20 kHz
    Rise time:  Tr = 0.35 / Bw
	Bw =  20 kHz   Tr = 17.5 us
	Bw = 100 kHz   Tr =  3.5 us

For our scanner:
    Velocity =  Vs = 518 mm/s
    Spot dia =  Ds = 2 um
    Rise time:  Tr = Ds / Vs = 3.8 us
    Bandwidth:  Bw = 0.35 / Tr  = 92 kHz
    Sample rate:  Sr = 5 * Bw   = 460 kHz

Measured rise time:
    Rise time:  Tr = 30 us
    Bandwidth:  Bw = 0.35 / Tr  = 12 kHz

    Why does the bandwidth seem so low?


----------------------------------------------------------------------------
## Sample an Image with Lissajous Pattern
----------------------------------------------------------------------------

    Idea is to have a rectilinear (X-Y) image of pixels much smaller than
    the sample spot, which is scanned in a Lissajous pattern.
    We want to generate the time series of samples.
    This models our confocal fiber scanning microscope.

Geometry

    Scan spot:
	Model as a circle (disc).  Optics may distort actual shape.
	Intensity from single mode fiber is a gaussian distribution.
	Spot coordinates are to center of spot.

	Sr = radius of spot, model

    Object plane:
	This is the object being scanned.
	Model as a rectilinear grid of pixels.
	Pixel coordinates are to center of pixel.

	Pw = pixel width, square.

    Assume  Pw << Sr  by a factor of around 2 or more.

Stationary Spot:
    Now lay the scan spot on the pixel grid.

    Quantize the alignment to put the spot center on center of nearest pixel.
    The idea is to approximate which pixels contribute to the Spot intensity
    value.  Take only the pixels whose center falls within the Spot circle.
    The relative pixels can be pre-determined based only Sr and Pw.
    Make Pw sufficiently smaller than Sr such that the errors at edge of
    the spot can be ignored.

    Now add up those pixel values and assign to the Spot value.

    Is = sum( nearest pixel intensities )

Spot motion:
    The spot is in motion, with a fixed sampling period Ts.
    Thus the spot may streak over several spot radiuses.
    What value to assign for this situation?

    Maybe add this detail after basic transformations are implemented.

Relative size of Spot and Pixel grid:

    Pw << 2*Sr    Pixel size much smaller than spot size.
	As in first idea above.
	Fine pixel resolution gives best detail for spot resolution.
	Idea is to substitute quantization of many pixels overlapping spot
	for computing overlap areas.

    Pw == 2*Sr    Pixel size and spot size about the same.
	Intuitively sensible for equivalent resolution.
	Mapping by compute circle overlap of possibly 4 pixels.
	Approximations may help.
	Pixel to Spot could use an approximation table quantized to a finer
	grid.

    Pw >> 2*Sr    Pixel size much larger than spot size.
	High spot resolution is lost in the pixel grid.
	Easy conversion, since at most only 4 pixels are involved.
	Might be interesting to explore.



